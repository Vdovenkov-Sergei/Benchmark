# Benchmark "4 QUERIES"
### Запуск программы:
 
1. После клонирования репозитория создайте папку (по умолчанию стоит `Data`), где будут храниться файлы `.сsv` и `.db`;  
2. Скачайте файлы `nyc_yellow_tiny.csv`, `nyc_yellow_big.csv` (можно один, можно оба) и поместите их в папку, созданную в предыдущем пункте; 
3. `Важное уточнение:` в исходных файлах содержатся несколько некорректные данные. Два последних столбца одинаковые и различаются только в регистре, причём последний столбец `Airport_fee` не имеет никаких данных. Это приводит к ошибке дубликатов при создании файла `.db`. Для решения проблемы удалите последний столбец в самом файле(`Airport_fee`);
4. Для настройки запуска программы откройте файл `config.py` и поправьте нужные Вам данные (кол-во попыток, названия базы данных, таблиц, файлов с данными, ваши данные для подключения к `PostgreSQL`, выполняемые модули);
5. Чтобы выполнить код, откройте файл `main.py` и запустите его;
    
Ссылка на файлы находится [тут](https://drive.google.com/drive/folders/1usY-4CxLIz_8izBB9uAbg-JQEKSkPMg6)

### О бенчмарке

`Бенчмаркинг баз данных` - это проверенный и четко определённый метод анализа и сравнения характеристик производительности баз данных или систем управления базами данных (СУБД). Один из таких бенчмарков носит название `4 QUERIES`. Для реализации этого бенчмарка будем использовать язык программирования Python. ![](Results/images/PY.jpg)

Pассмотрим в работе ряд модулей:
* [SQLite3](https://docs.python.org/3/library/sqlite3.html)
* [Pandas](https://pandas.pydata.org/docs/)
* [Psycopg2](https://www.psycopg.org/docs/)
* [Duckdb](https://duckdb.org/docs/)
* [SQLalchemy](https://docs.sqlalchemy.org/en/20/)

#### Запросы

```SQL
SELECT "VendorID", COUNT(*) FROM "trips" GROUP BY 1;
```
1. Этот запрос выполняет подсчёт кол-ва записей в таблице `trips` для каждого уникального значения столбца `VendorID` и группирует результаты по типу такси (`VendorID`).

```SQL
SELECT "passenger_count", AVG("total_amount") FROM "trips" GROUP BY 1;
```
2. Этот запрос выполняет вычисление среднего значения стоимости поездки (`total_amount`) для каждого уникального значения числа пассажиров (`passenger_count`) в таблице `trips`.

```SQL
SELECT "passenger_count", EXTRACT(year FROM "tpep_pickup_datetime"), COUNT(*)
FROM "trips" GROUP BY 1, 2;
```
3. Этот запрос извлекает информацию из таблицы trips о кол-ве пассажиров (`passenger_count`), годе по времени взятия такси (`tpep_pickup_datetime`), и подсчитывает кол-во записей, соответствующих каждому уникальному значению комбинации числа пассажиров и года взятия такси.

```SQL
SELECT "passenger_count", EXTRACT(year FROM "tpep_pickup_datetime"), ROUND("trip_distance"), COUNT(*) FROM "trips" GROUP BY 1, 2, 3 ORDER BY 2, 4 DESC;
```
4. Этот запрос извлекает информацию из таблицы trips о кол-ве пассажирор (`passenger_count`), годе по времени взятия такси (`tpep_pickup_datetime`), округлённой дистанции поездки (`trip_distance`) и подсчитывает кол-во записей для каждой уникальной комбинации этих параметров. Результаты сортируются по году взятия такси в порядке возрастания, а кол-во записей в каждой группе упорядочивается по убыванию.

### Итоги, выводы

* Результаты работы на маленьком файле:
![](Results/images/launch_tiny.png)
![](Results/images/graphic_tiny.png)

* Результаты работы на большом файле:
![](Results/images/launch_big.png)
![](Results/images/graphic_big.png)
